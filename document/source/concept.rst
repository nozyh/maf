mafの使い方、諸概念、ユーティリティ
===================================

本章ではmafの諸概念を紹介したあと、具体例を通して便利な機能を紹介していきます。
読者には以下の知識を仮定します。

- Pythonの基本的な使い方
- wafの基本的な使い方

mafの使い方
-----------

まずは最も簡単なmafスクリプトを書いて、使い方を学びましょう。
最新版のwafと ``maf.py`` をダウンロードして、同じディレクトリに置きます。
wafファイルには実行可能フラグを立てておくと良いでしょう。

.. code-block:: bash

   $ chmod +x waf

次に以下の内容の ``wscript`` ファイルを作成します。

.. code-block:: python

   import maf

   def options(opt):
       opt.load('maf')

   def configure(conf):
       conf.load('maf')

   def experiment(exp):
       pass

この ``wscript`` ファイルは何もしません。
wafをビルドに用いる場合には ``build`` 関数を書きましたが、mafで実験を行う場合には代わりに ``experiment`` 関数を書きます。
引数 ``exp`` は ``build`` 関数の場合の引数にmaf用の拡張を施したものです。

まずはこのスクリプトを実行できるか試しましょう。
以下のコマンドを入力します。

.. code-block:: bash

   $ ./waf configure
   $ ./waf experiment

wafでビルドする場合には ``./waf build`` ないし省略して ``./waf`` を実行しますが、mafで実験コードを実行する場合には ``./waf experiment`` を実行します。
以上で「何もしない実験」が実行されます。

以降、 ``experiment`` 関数の中に実験計画を記述していきます。
次節ではその書き方に入る前に、まずはmafの最重要概念であるメタノードとパラメータについて解説します。

ノードとメタノードとパラメータ
------------------------------

本節ではwafにおけるノードの概念の紹介（復習）と、mafにおいてこれをパラメータと結びつけたメタノードという概念を概説します。
その後、mafにおけるタスクの書き方について、メタノードとパラメータに関わる挙動に焦点を当てて解説します。

wafノード
~~~~~~~~~

wafにおいて、wscript中で参照するファイルやディレクトリのことを **ノード** と呼びます。
ノードは基本的にはファイルに対応しますが、これにバージョン情報やハッシュ値などが紐付けられています。
また、ノードに対応するファイルはビルドディレクトリ（通常は ``build`` という名前を持つ）以下にあることもあれば、ソースディレクトリ（通常は ``waf`` 自身があるディレクトリ）以下にあることもあります。
wafはノード間の依存関係を管理して、自動的にビルドに必要なタスクを生成します。
また、各タスクごとに入力ファイルのバージョン情報やハッシュ値の変化を検出して、再ビルドの際には必要十分な部分だけを再実行します。

メタノード（パラメータ付けられたノード）
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mafではタスクにパラメータを指定することができます。
例えば次の例では、パラメータごとに異なる内容のファイルを生成しています。

.. code-block:: python

   exp(target='my_out',
       parameters=[{'name': 'Taro'},
                   {'name': 'Jiro'},
                   {'name': 'Saburo'}],
       rule='echo ${name} > ${TGT}')

``parameters`` に辞書の配列を指定することで、タスクにパラメータの集合を設定することができます。
各辞書のキーと値はともにハッシュ化可能でなければなりません。
パラメータの内容は ``rule`` 内で参照することができます。

mafは上の関数呼び出しで、3つの異なるwafタスクを生成します。
これらはパラメータが異なり、出力ファイルも異なります。
各出力ファイルは ``build/experiment/my_out`` ディレクトリ以下に生成されます。
ノード ``my_out`` は異なるパラメータに対応する複数のノードを含んでいます。
このノード ``my_out`` のことを **メタノード** と呼びます。

mafではメタノードを一つのノードであるかのように扱うことができます。
例えば ``my_out`` の各ファイルの後ろに特定の文字列を加えるタスクは、以下のように書くことができます。

.. code-block:: python

   exp(source='my_out',
       target='my_name',
       rule='echo Sato >> ${TGT}')

この例の場合、入力ノード ``my_out`` はメタノードなので、各パラメータごとに別々のタスクが生成されます。
どんなパラメータがあるかはメタノード ``my_out`` に紐付けられているので、改めて記述する必要はありません。
このとき、出力ノード ``my_name`` もメタノードとなり、 ``my_out`` に含まれる各ノードに対応するノードがこの中に生成されます。
``my_name`` 内の各ノードには、 ``my_out`` の対応するノードと同じパラメータが紐付けられます。
mafではこのように、パラメータを明示することなくメタノードに対する処理を書くことができます。

メタノードに関するより詳しい仕様
--------------------------------

メタノードとパラメータ指定にはいくつかのバリエーションがあります。
また、実験計画を記述する上では、実験結果を集約する操作も必要になります。
この節ではそれらについて一つずつ解説していきます。

複数パラメータの生成
~~~~~~~~~~~~~~~~~~~~

パラメータは辞書の配列で指定しますが、パラメータの種類が多く、それらの様々な組合せを試したいケースは多いです。
このような場合に、同じ種類のパラメータに対する範囲を何度も書くのはメンテナンスの観点から望ましくありません。
そこでmafにはパラメータの組合せを生成する便利な関数が2つ用意されています。

一つ目は **maf.product** です。
各パラメータ名に対するパラメータのリストを指定すると、すべての組合せを生成します。
productという名前は集合の直積を表します。

.. code-block:: python

   maf.product({'method': ['PA2', 'AROW'],
                'C': [0.1, 1, 10]})

   # => [{'method': 'PA2', 'C': 0.1},
   #     {'method': 'PA2', 'C': 1},
   #     {'method': 'PA2', 'C': 10},
   #     {'method': 'AROW', 'C': 0.1},
   #     {'method': 'AROW', 'C': 1},
   #     {'method': 'AROW', 'C': 10}]
   # (順番が入れ替わる可能性はあります)

もう一つは **maf.sample** です。
各パラメータ名に対してパラメータを生成する関数を渡すと、それらを用いて指定した数の組合せを生成します。
関数の代わりに数値の対を渡すとその区間の連続一様分布を用います。
関数の代わりに値のリストを渡すと、リストから値を選ぶような離散一様分布を用います。
パラメータの最適化を行う際に、直積集合よりも少ない組合せで効率的に実験を行うのに有効です。

.. code-block:: python

   maf.sample(4, {'method': ['PA2', 'AROW'],
                  'C': lambda: math.pow(10, random.uniform(-1, 1))})

メタノードの組合せ
~~~~~~~~~~~~~~~~~~

``source`` として複数のメタノードを指定することもできます。
この場合、基本的にはそれらが含むノードの全組み合わせが用いられます。
ただし、組み合わされたノード同士が同じキーで違う値のパラメータを持つ場合、その組合せは無視されます。

例えば次の例を見てみましょう。

.. code-block:: python

   exp(target='x',
       parameters=[{'A': 1, 'B': 1},
                   {'A': 2, 'B': 10},
                   {'A': 3, 'B': 1}],
       rule=...)

   exp(target='y',
       parameters=[{'A': 1, 'C': -1},
                   {'A': 2, 'C': 0},
                   {'A': 3, 'C': 1}],
       rule=...)

   exp(source='x y',
       target='z',
       rule=...)

パラメータ ``A, B`` を持つメタノード ``x`` と、パラメータ ``A, C`` を持つメタノード ``y`` があり、それらを入力としてメタノード ``z`` を出力しています。
この場合、 ``z`` を出力するタスクでは ``x`` と ``y`` のノードの全組合せが試されますが、そのうちパラメータ ``A`` の値が食い違っている組合せについてはタスクを実行しません。

よって ``z`` は以下のパラメータに対応するノードの集合となります ::

  {'A': 1, 'B': 1, 'C': -1},
  {'A': 2, 'B': 10, 'C': 0},
  {'A': 3, 'B': 1, 'C': 1}.

``x`` も ``y`` も3通りのパラメータを持ちますが、 ``z`` は3×3=9通りではなく、組合せが正しい3通りのみを持っていることに注目してください。

メタノードが入力にある場合のパラメータ指定
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

mafでは ``parameters`` を指定することでタスクおよび出力ノードにパラメータを設定できることを見てきました。
パラメータはさらに、入力ノードにメタノードが含まれる場合にも指定することができます。

入力ノードにメタノードがあり、かつ ``parameters`` にパラメータを指定している場合、メタノードのパラメータと ``parameters`` に指定されたパラメータのすべての組合せが試されます。
このとき、同じキーに対して異なる値が対応する組合せについてはスキップします。
この挙動は、前項で解説した、複数メタノードを入力に指定した場合と同じです。

次の例を考えます。

.. code-block:: python

   exp(target='x',
       parameters=maf.product({'A': [1, 2, 3], 'B': [1, 10]}),
       rule=...)

   exp(source='x',
       target='y',
       parameters=[{'A': 1, 'C': -1},
                   {'A': 2, 'C': 0},
                   {'A': 3, 'C': 1}],
       rule=...)

この例ではメタノード ``x`` を入力とするタスク生成で同時に ``parameters`` が指定されています。
このとき出力メタノード ``y`` は以下のパラメータを持つことになります::

  {'A': 1, 'B': 1, 'C': -1},
  {'A': 1, 'B': 10, 'C': -1},
  {'A': 2, 'B': 1, 'C': 0},
  {'A': 2, 'B': 10, 'C': 0},
  {'A': 3, 'B': 1, 'C': 1},
  {'A': 3, 'B': 10, 'C': 1}.

メタノードの集約
~~~~~~~~~~~~~~~~

実験結果を評価するためには、実験の出力を集約する操作が必要になります。
たとえばグラフの描画や、複数回の試行に対して平均をとる操作などがこれにあたります。
mafでは、メタノードが持つ複数のパラメータに対するノード集合に対して一つのノードを出力するようなタスクを **集約タスク** と呼びます。
集約タスクを用いれば、このような集約操作を書くことができます。

タスクを書く際に ``for_each`` または ``aggregate_by`` を指定した場合に、そのタスクは集約タスクとなります。
集約する際に、どのパラメータについて集約するかをこれらのキーで選びます。
これらにはパラメータ名のリストを指定します。
``for_each`` と ``aggregate_by`` を同時に指定することができません。
また、集約タスクでは必ず入力ノードにメタノードが含まれていなければなりません。

``for_each`` を指定した場合、そこに列挙されたパラメータ名は、出力メタノードに保存されます。
すなわち、そこに列挙されていないパラメータについて集約を行います。
たとえば次の例をご覧ください。

.. code-block:: python

   exp(target='raw_output',
       parameters=maf.product({'A': [0, 1, 2],
                               'B': [-1, 0, 1]}),
       rule='echo A:${A} B:${B} > ${TGT}')

   exp(source='raw_output',
       target='output_for_each_A',
       for_each=['A'],
       rule='cat ${SRC} > ${TGT}')

   # 注意: ruleに指定した文字列内で ${SRC} と書いた場合、
   # そこには入力ノードすべてのファイル名がスペース区切りで列挙される。

この例の場合、 ``for_each=['A']`` の指定により、各 ``A`` の値ごとに ``output_for_each_A`` のノードを生成するタスクが実行されます。
すなわち、 ``A`` の値が等しくて ``B`` の値が異なる3つの入力ノードに対して1つのタスクが作られます。
``for_each`` を用いた指定は、残すパラメータが少ない場合に便利です。
すべてのパラメータについて集約を行い、一つのファイルだけを出力したい場合には、 ``for_each`` に空リストを指定します（ ``for_each`` 自体を省略してしまうと、集約タスクになりません）。

一方、 ``aggregate_by`` を指定した場合、逆にそこに列挙されたパラメータについて集約を行います。
すなわち、それ以外のパラメータを ``for_each`` に指定した場合と同じ挙動をします。
上の例における ``for_each=['A']`` を ``aggregate_by=['B']`` に置き換えた場合、結果は等しくなります。
``aggregate_by`` を用いた指定は、集約するパラメータが少ない場合に便利です。

JSON形式の入出力ファイル
------------------------

これから紹介するmafのユーティリティを活用するには、実験結果などをJSON形式で保存する必要があります。
JSON形式のファイルは、そのまま全体がひとつのJSON値になっているようなテキストファイルです。
mafのユーティリティで用いられるJSONファイルは、一つのオブジェクトまたはオブジェクトの配列です。
各オブジェクトは入れ子構造を持たず、文字列のキーと文字列または数値の値のみを持つことを仮定しています。

JSON形式のファイルを用いることで、mafのユーティリティを使って以下の様なことができます。

- 特定のキーについて最大値を取ったり、キーごとに平均を取るなどといった集約処理
- グラフ描画用に、特定のキーに関する値の列を取り出す処理

mafユーティリティ関数
---------------------

mafにはいくつかの便利な関数が定義されています。
そのうち、すでにパラメータリストを生成するための ``maf.product`` や ``maf.sample`` を紹介しました。
ここではその他のユーティリティ関数群を簡単に紹介します。

簡単な統計処理
~~~~~~~~~~~~~~

入力ファイルが前節で述べたようなJSON形式の時、それらのJSONに関する簡単な統計値を計算することができます。

``maf.max`` ルールを用いると、特定のキーについて最大値を取ることができます。
例えば機械学習において、ハイパーパラメータをいくつか試したあとで最も良かった結果だけを取り出したい場合に用います。
``maf.max`` は集約ルールのため、 ``for_each`` または ``aggregate_by`` と共に用います。
``maf.max`` は最大値に対応する入力JSONオブジェクトに、そのJSONオブジェクトを含むノードに対応する集約パラメータを付け足したものを出力します。

.. code-block:: python

   # result には実験結果が {"accuracy": 数値} の形で入っているとする。
   # result がパラメータ A, B, C を持っている時、aggregate_by=['C'] と書けば各
   # (A, B) に対して正解率が最大となる C を探し、そのときの結果のみをターゲット
   # にコピーする。
   exp(source='result',
       target='max_accuracy',
       aggregate_by=['C'],
       rule=maf.max('accuracy'))

他にも、すべてのキーについて平均値を取る ``maf.average`` ルールがあります。

実験結果のプロット
~~~~~~~~~~~~~~~~~~

実験手順の最終段階は、いつだってグラフの描画です。
Pythonには便利なグラフ描画ライブラリとしてmatplotlibがあります。
mafではJSON形式の実験結果をmatplotlibに流しこむための便利な仕組みがあります。

``maf.plot_by`` ルールは、実際にmatplotlibに描画を行う関数を受け取ります。
このコールバック関数は、実験結果そのものではなく、それを ``maf.PlotData`` というクラスのオブジェクトに変換したものを引数に取ります。
``maf.PlotData`` からは、matplotlibに入力するためのカラムベクトルを取り出すことができます。

次の例では、JSON形式で書かれた実験結果 ``result`` をもとに折れ線グラフを描画しています。
実験結果は ``{"time": 数値, "accuracy": 数値}`` という形式で書かれており、各入力ノードはこのようなJSONオブジェクトの配列になっています。
各入力ノードは異なるパラメータ ``method`` を持ちます。
このとき、横軸が ``time`` で縦軸が ``accuracy`` の折れ線グラフを各 ``method`` ごとに描画しています。

.. code-block:: python

   def plot_my_result(figure, data):
       axes = figure.add_subplot(111)
       key_to_xys = data.get_data_2d('time', 'accuracy', key='method')

       for key in key_to_xys:
           x, y = key_to_xys[key]
           axes.plot(x, y, label=key)

       axes.legend(loc='best')

   exp(source='result',
       target='plot.png',
       for_each=[],
       rule=maf.plot_by(plot_my_result))

単純な折れ線グラフに関しては、さらに簡単な ``maf.plot_line`` も用意しています。
ただしこちらは自由度が低いので、グラフの体裁をいじりたい場合には ``maf.plot_by`` を用いてmatplotlibを直接使うことをおすすめします。

.. code-block:: python

   # 上の例は以下とほとんど同じ処理（凡例だけ少し異なる）。
   exp(source='result',
       target='plot.png',
       for_each=[],
       rule=maf.plot_line('time', 'accuracy', legend={'key': 'method'}))
